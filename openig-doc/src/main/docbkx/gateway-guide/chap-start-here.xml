<?xml version="1.0" encoding="UTF-8"?>
<!--
  ! CCPL HEADER START
  !
  ! This work is licensed under the Creative Commons
  ! Attribution-NonCommercial-NoDerivs 3.0 Unported License.
  ! To view a copy of this license, visit
  ! http://creativecommons.org/licenses/by-nc-nd/3.0/
  ! or send a letter to Creative Commons, 444 Castro Street,
  ! Suite 900, Mountain View, California, 94041, USA.
  !
  ! You can also obtain a copy of the license at
  ! src/main/resources/legal-notices/CC-BY-NC-ND.txt.
  ! See the License for the specific language governing permissions
  ! and limitations under the License.
  !
  ! If applicable, add the following below this CCPL HEADER, with the fields
  ! enclosed by brackets "[]" replaced with your own identifying information:
  !      Portions Copyright [yyyy] [name of copyright owner]
  !
  ! CCPL HEADER END
  !
  !      Copyright 2014 ForgeRock AS
  !
-->
<chapter xml:id="chap-start-here"
         xmlns="http://docbook.org/ns/docbook" version="5.0" xml:lang="en"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://docbook.org/ns/docbook
                             http://docbook.org/xml/5.0/xsd/docbook.xsd"
         xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Understanding ${projectName}</title>

 <para>
  This chapter introduces ${projectName}, briefly covering essential concepts.
 </para>

 <section xml:id="about">
  <title>About ${projectName}</title>

  <para>
   Most organizations have valuable existing services
   that they cannot easily integrate into newer architectures.
   Often, however, they also cannot change the existing services.
   Without a gateway to bridge the gap,
   some client applications cannot communicate with these existing services.
  </para>

  <figure xml:id="figure-missing-gateway">
   <title>Missing Gateway</title>

   <mediaobject>
    <alt>Missing Gateway</alt>
    <imageobject>
     <imagedata fileref="images/missing-gateway.png" format="PNG" />
    </imageobject>
    <textobject>
     <para>
      Sometimes new client requests are not appropriate for existing services,
      or service responses are not appropriate for new clients.
     </para>
    </textobject>
   </mediaobject>
  </figure>

  <para>
   ${projectName} works as an HTTP gateway, also known as a
   <link
    xlink:show="new"
    xlink:href="http://en.wikipedia.org/wiki/Reverse_proxy"
   >reverse proxy</link>.
   You deploy ${projectName} on the network
   so that it intercepts both client requests and also server responses.
  </para>

  <figure xml:id="figure-gateway-deployed">
   <title>${projectName} Deployed</title>

   <mediaobject>
    <alt>${projectName} Deployed</alt>
    <imageobject>
     <imagedata fileref="images/gateway-deployed.png" format="PNG" />
    </imageobject>
    <textobject>
     <para>
      ${projectName} helps integrate existing services into newer architectures.
     </para>
    </textobject>
   </mediaobject>
  </figure>

  <para>
   Clients then exchange with protected servers through ${projectName}.
   This means that without touching either clients or servers,
   you can configure ${projectName} to add new capabilities
   to existing services.
  </para>

  <itemizedlist>
   <para>
    The list that follows names some of what you can add by using ${projectName}.
   </para>

   <listitem>
    <para>
     Access management integration
    </para>
   </listitem>

   <listitem>
    <para>
     Application &amp; API security
    </para>
   </listitem>

   <listitem>
    <para>
     Credential replay
    </para>
   </listitem>

   <listitem>
    <para>
     OAuth 2.0 support
    </para>
   </listitem>

   <listitem>
    <para>
     OpenID Connect 1.0 support
    </para>
   </listitem>

   <listitem>
    <para>
     Network traffic control
    </para>
   </listitem>

   <listitem>
    <para>
     Proxy with request &amp; response capture
    </para>
   </listitem>

   <listitem>
    <para>
     Request &amp; response rewriting
    </para>
   </listitem>

   <listitem>
    <para>
     SAML 2.0 federation support
    </para>
   </listitem>

   <listitem>
    <para>
     Single sign-on
    </para>
   </listitem>
  </itemizedlist>

  <para>
   ${projectName} supports these capabilities
   as out-of-the-box configuration options.
   Once you understand the essential concepts covered in this chapter,
   try the demonstrations in this guide to see for yourself
   how to add these features by using ${projectName}.
  </para>
 </section>

 <section xml:id="the-exchange">
  <title>The Exchange</title>

  <para>
   ${projectName} handles HTTP requests and responses
   with a wrapper called the <firstterm>exchange</firstterm>.
  </para>

  <para>
   The ${projectName} exchange encapsulates HTTP requests and responses
   that pass through ${projectName},
   as well as the principal associated with the request,
   the session context associated with the client,
   and any other state information needed.
   ${projectName} makes it easy
   to access arbitrary state information through the exchange
   so that you can use it throughout the duration of the exchange,
   even when the exchange calls for interaction with additional services.
  </para>

  <para>
   In addition, ${projectName} includes information in the exchange
   about the client that made the incoming request,
   such as the client host, port, and IP address,
   and also the user-agent description,
   the login of the user making the request,
   and the X.509 certificates presented by the client
   when these are available as part of the request.
  </para>
 </section>

 <section xml:id="the-configuration">
  <title>The Configuration</title>

  <para>
   ${projectName} represents its configuration in JSON format,
   which is store in flat files.<footnote>
    <para>
     ${projectName} also uses additional file formats for SAML 2.0,
     but the primary configuration files are in JSON format.
    </para>
   </footnote>
   You configure ${projectName} by editing the JSON flat files.
  </para>

  <para>
   After installation, you add at least one configuration file.
   Each configuration file holds a JSON object.
   At minimum, the JSON object specifies a "handler" to deal with the exchange.
  </para>

  <para>
   The following very simple configuration routes exchanges
   to be handled according to separate route configurations.
  </para>

  <programlisting language="javascript">
{
    "handler": {
        "type": "Router"
    }
}
  </programlisting>

  <para>
   The "handler" indicates which object ${projectName} invokes first.
   A handler is an object responsible for producing a response to a request,
   therefore every route must call a handler.
  </para>

  <para>
   Notice in this case that the "handler" field takes an object as its value.
   This is an inline declaration.
   If you only use the object once where it is declared,
   then it makes sense to use an inline declaration.
  </para>

  <para>
   To change the definition of an object defined by default
   or when you need to declare an object once and use it multiple times,
   you declare object definitions in the "heap",
   and then reference the objects by "name".
   You can also use this technique instead of inline declarations.
  </para>

  <para>
   The following example declares an identical "Router" object as above
   and references it by its name.
  </para>

  <programlisting language="javascript">
{
    "handler": "My Router",
    "heap": [
        {
            "name": "My Router",
            "type": "Router"
        }
    ]
}
  </programlisting>

  <para>
   Notice that the "heap" takes an array.
   As the "heap" holds configuration objects all at the same level,
   you can impose any hierarchy or order that you like when referencing objects.
   Yet, when you declare all objects in the "heap" and reference them by name,
   neither hierarchy nor ordering are obvious
   from the structure of the configuration file alone.
  </para>

  <itemizedlist>
   <para>
    Each configuration object has a "type", a "name", and an optional "config".
   </para>

   <listitem>
    <para>
     The "type" must be the type name of the configuration object.<footnote>
     <para>
      For built-in objects, you can use the short name alias.
      If the object has no alias,
      use the fully qualified class name
      of the Java class implementing the object.
     </para>
    </footnote>
    </para>

    <para>
     As you see in the rest of this guide
     and in the <citetitle>Reference</citetitle>,
     ${projectName} defines many types for different purposes.
    </para>
   </listitem>

   <listitem>
    <para>
     The "name" takes a string that is unique in the list of objects.
    </para>

    <para>
     You can omit this field when declaring objects inline.
    </para>
   </listitem>

   <listitem>
    <para>
     The contents of the "config" object depend on the "type".
    </para>

    <para>
     When all the configuration settings for the type are optional,
     the "config" field is also optional, as in this example.
     If all configuration settings are optional,
     then omitting the "config" field,
     or setting the "config" field to an empty object, "config": {},
     or setting "config": null
     all signify that the object uses default settings.
    </para>
   </listitem>
  </itemizedlist>

  <para>
   The configuration can specify additional objects as well.
   For example, you can configure an "HttpClient"
   that ${projectName} uses to connect to servers.
   The following "HttpClient" configuration uses defaults for all settings,
   except "hostnameVerifier", which it configures to
   verify host names in SSL certificates in the same way as most browsers.
  </para>

  <programlisting language="javascript">
{
    "name": "HttpClient",
    "type": "HttpClient",
    "config": {
        "hostnameVerifier": "BROWSER_COMPATIBLE"
    }
}
  </programlisting>

  <para>
   <firstterm>Decorators</firstterm> are additional heap objects
   that let you extend what another object can do.
   For example, a "CaptureDecorator" enables filters and handlers
   to log requests and responses.
   A "TimerDecorator" logs processing times.
   You decorate the configuration of other objects
   with the names of decorators as field names.
   ${projectName} defines both a "CaptureDecorator" named "capture"
   and also a "TimerDecorator" named "timer" by default.
   You can therefore log requests, responses, and processing times
   by adding decorations as shown in the following example.
  </para>

  <programlisting language="javascript">
{
    "handler": {
        "type": "Router",
        "capture": [ "request", "response" ],
        "timer": true
    }
}
  </programlisting>

  <para>
   In addition to decorators, ${projectName} also creates
   other utility objects with default settings,
   including "HttpClient", "LogSink", and "TemporaryStorage".
   You can reference these objects by name without configuring them
   unless you need to override the default configurations.
  </para>

  <para>
   Routes, mentioned here
   and described in more detail in <xref linkend="routing" />,
   inherit settings from their parent configurations.
   This means that you can
   configure global objects in the "heap" of the base configuration for example,
   and then reference the objects by name
   in any other ${projectName} configuration.
  </para>
 </section>

 <section xml:id="routing">
  <title>Routing</title>

  <para>
   ${projectName} routing lets you use multiple configuration files.
   Routing also lets ${projectName} reload configurations
   that you change at runtime without restarting ${projectName}.
  </para>

  <para>
   You can use routing where ${projectName} protects multiple services,
   or multiple different endpoints of the same service.
   You can also use routing when handling an exchange involves multiple steps,
   for example because you must redirect the client
   to authenticate with an identity provider
   before accessing the service.
  </para>

  <para>
   A <firstterm>router</firstterm>,
   as shown in <xref linkend="the-configuration" />,
   takes responsibility for managing the routes used,
   periodically reloading changed routes
   unless configured to load them only at startup.
  </para>

  <para>
   Notice in the example that the router does not specify any routes.
   Instead, routes optionally specify their own "condition".
   If a route "condition" is true, then the route handles the exchange.
  </para>

  <para>
   The following example specifies a condition
   that is true when the incoming request path is <literal>/login</literal>.
  </para>

  <programlisting language="javascript">
"condition": "${matches(exchange.request.uri.path, '^/login')}"
  </programlisting>

  <para>
   If the route has no "condition", or if the value of the condition is null,
   then the route matches any exchange.
   Furthermore, ${projectName} orders routes lexicographically by name.
  </para>

  <para>
   You can use these features to have both optional and default routes.
   For example, you could name your routes to check conditions in order:
   <filename>01-login.json</filename>,
   <filename>02-protected.json</filename>,
   <filename>99-default.json</filename>.
   Alternatively, you can name routes using the "name" property on the route.
  </para>

  <para>
   A router configuration can specify where to look for route files.
   As a "Router" is a kind of "handler", routes can have routers, too.
  </para>
 </section>

 <section xml:id="filters-handlers-chains">
  <title>Filters, Handlers, &amp; Chains</title>

  <para>
   Routing only delegates exchange handling.
   It does not actually deal with exchanges.
   To deal with an exchange, you chain together filters and handlers.
  </para>

  <itemizedlist>
   <listitem>
    <para>
     A <firstterm>handler</firstterm> either delegates to another handler,
     or it produces a response.
    </para>

    <para>
     One way of producing a response is
     to send a request to and receive a response from an external service.
     In this case, ${projectName} acts as a client of the service,
     often on behalf of the client whose request initiated the exchange.
    </para>

    <para>
     Another way of producing a response is
     to build a response either statically or based on something in the exchange.
     In this case, ${projectName} plays the role of server,
     generating a response to return to the client.
    </para>
   </listitem>

   <listitem>
    <para>
     A <firstterm>filter</firstterm> transforms something in the exchange.
    </para>

    <para>
     A filter can leave the exchange unchanged.
     Alternatively a filter can even replace the request or the response,
     for example generating a static request that replaces the client request.
     Other filters only add or change some of the data in the exchange.
    </para>
   </listitem>

   <listitem>
    <para>
     A <firstterm>chain</firstterm> takes a list of filters and one handler.
     (The list of filters can be empty.)
    </para>

    <para>
     Like a router, a chain itself is technically a handler.
     You can therefore place a chain anywhere in the configuration
     that you can place a handler.
    </para>

    <para>
     The chain dispatches processing to the filters in order,
     and then to the handler.
    </para>

    <para>
     Initially the filters process the incoming exchange,
     with each filter handing off to the next filter and finally the handler.
     Then after the handler produces the response,
     the filters process the outgoing exchange on its way to the client.
     The same filter can process the incoming request and the outgoing response.
     Many filters, however, either process the request or the response.
    </para>
   </listitem>
  </itemizedlist>

  <para>
   The following diagram shows the flow inside a chain that has
   a request filter transforming the request,
   a response filter transforming the response,
   and a handler sending a request to a service to get a response.
   Notice how the flow traverses the filters in reverse order
   when the outgoing exchange comes back from the handler.
  </para>

  <figure xml:id="figure-chain">
   <title>Flow Inside a Chain</title>

   <mediaobject>
    <alt>Flow Inside a Chain</alt>
    <imageobject>
     <imagedata fileref="images/chain.png" format="PNG" />
    </imageobject>
    <textobject>
     <para>
      In a chain the incoming exchange is processed by the request filters,
      then the handler produces a response.
      The outgoing chain is then processed by response filters.
     </para>
    </textobject>
   </mediaobject>
  </figure>

  <para>
   The following route configuration demonstrates the flow,
   but without an external service.
  </para>

  <programlisting language="javascript"><![CDATA[
{
    "handler": {
        "type": "Chain",
        "comment": "Base configuration defines the capture decorator",
        "config": {
            "filters": [
                {
                    "type": "HeaderFilter",
                    "comment": "Same header on all requests",
                    "config": {
                        "messageType": "REQUEST",
                        "add": {
                            "X-MyHeaderFilter": [
                                "Added by HeaderFilter to request"
                            ]
                        }
                    }
                },
                {
                    "type": "HeaderFilter",
                    "comment": "Remove X-Powered-By from response",
                    "capture": "response",
                    "config": {
                        "messageType": "RESPONSE",
                        "remove": [
                            "X-Powered-By"
                        ]
                    }
                }
            ],
            "handler": {
                "type": "StaticResponseHandler",
                "comment": "Same response to all requests",
                "capture": "request",
                "config": {
                    "status": 200,
                    "reason": "OK",
                    "headers": {
                        "X-Powered-By": [
                            "${projectName}"
                        ]
                    },
                    "entity": "<html><p>Hello, World!</p></html>"
                }
            }
        }
    }
}
  ]]></programlisting>

  <orderedlist>
   <para>
    When the "Chain" gets the request, it processes the exchange as follows.
   </para>

   <listitem>
    <para>
     The first "HeaderFilter" adds a header to the incoming request.
    </para>
   </listitem>

   <listitem>
    <para>
     The second "HeaderFilter" deals with responses,
     so it simply passes the exchange to the handler.
    </para>
   </listitem>

   <listitem>
    <para>
     The "StaticResponseHandler" captures (logs) the request.
    </para>
   </listitem>

   <listitem>
    <para>
     The "StaticResponseHandler" itself produces a response
     having an entity body and a header.
    </para>
   </listitem>

   <listitem>
    <para>
     The second "HeaderFilter" captures (logs) the response.
    </para>
   </listitem>

   <listitem>
    <para>
     The second "HeaderFilter" removes the header added to the response.
    </para>
   </listitem>

   <listitem>
    <para>
     The first "HeaderFilter" deals with requests,
     so it simply passes the outgoing exchange back to ${projectName}.
    </para>
   </listitem>
  </orderedlist>

  <para>
   Suppose this chain configuration is the only route active for the request.
   In that case, the flow produces the following.
  </para>

  <programlisting language="http"><![CDATA[
### Original request from user-agent
GET / HTTP/1.1
Host: www.example.com:8080
Accept: */*

### Captured incoming request (inside ${projectName} exchange)
GET / HTTP/1.1
X-MyHeaderFilter: Added by HeaderFilter to request
Accept: */*
Host: www.example.com:8080

### Captured outgoing response (inside ${projectName} exchange)
HTTP/1.1 200 OK
Content-Length: 33
X-Powered-By: ${projectName}

<html><p>Hello, World!</p></html>

### Final response to user-agent
HTTP/1.1 200 OK
Content-Length: 33

<html><p>Hello, World!</p></html>
  ]]></programlisting>
 </section>

 <section xml:id="config-comments">
  <title>Comments in ${projectName} Configuration Files</title>

  <para>
   JSON does not specify a notation for comments.
  </para>

  <para>
   However, when ${projectName} does not recognize a JSON field name,
   it ignores the field.
   This makes it possible to use comments in configuration files.
  </para>

  <variablelist>
   <para>
    To make your configuration files easier to read,
    use the following conventions when commenting.
   </para>

   <varlistentry>
    <term>"comment"</term>
    <listitem>
     <para>
      Use the "comment" fields to add text comments.
     </para>

     <para>
      The following "CaptureDecorator" configuration includes a text comment.
     </para>

     <programlisting language="javascript">
{
    "name": "capture",
    "type": "CaptureDecorator",
    "comment": "Write request and response information to the LogSink",
    "config": {
        "captureEntity": true
    }
}
     </programlisting>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>"_<replaceable>field-name</replaceable>"</term>
    <listitem>
     <para>
      Use an underscore (<literal>_</literal>) to comment a field temporarily.
     </para>

     <para>
      The following "CaptureDecorator" configuration has
      <literal>"captureEntity": true</literal> commented out.
      As a result, it uses the default setting
      (<literal>"captureEntity": false</literal>).
     </para>

     <programlisting language="javascript">
{
    "name": "capture",
    "type": "CaptureDecorator",
    "config": {
        "_captureEntity": true
    }
}
     </programlisting>
    </listitem>
   </varlistentry>
  </variablelist>
 </section>

 <section xml:id="where-to-go-from-here">
  <title>Where To Go From Here</title>

  <para>
   Now that you understand the essential concepts,
   start using ${projectName} with the help of the following chapters.
  </para>

  <variablelist>
   <varlistentry>
    <term><link
     xlink:show="new"
     xlink:href="gateway-guide#chap-quickstart"
     xlink:role="http://docbook.org/xlink/role/olink"
     ><citetitle>Getting Started</citetitle></link>
    </term>
    <listitem>
     <para>
      This chapter shows you how to get ${projectName} up and running quickly.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><link
     xlink:show="new"
     xlink:href="gateway-guide#chap-install"
     xlink:role="http://docbook.org/xlink/role/olink"
     ><citetitle>Installation in Detail</citetitle></link>
    </term>
    <listitem>
     <para>
      This chapter covers more advanced installation procedures.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><link
     xlink:show="new"
     xlink:href="gateway-guide#chap-credentials-tutorial"
     xlink:role="http://docbook.org/xlink/role/olink"
     ><citetitle>Getting Login Credentials From Data Sources</citetitle></link>
    </term>
    <listitem>
     <para>
      This chapter shows you how to configure ${projectName}
      to look up credentials in external sources, such as a file or a database.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><link
     xlink:show="new"
     xlink:href="gateway-guide#chap-password-capture-replay-tutorial"
     xlink:role="http://docbook.org/xlink/role/olink"
     ><citetitle>Getting Login Credentials From OpenAM</citetitle></link>
    </term>
    <listitem>
     <para>
      This chapter walks you through an OpenAM integration
      with OpenAM's password capture and replay feature.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><link
     xlink:show="new"
     xlink:href="gateway-guide#chap-federation"
     xlink:role="http://docbook.org/xlink/role/olink"
     ><citetitle>${projectName} as a SAML 2.0 Service Provider</citetitle></link>
    </term>
    <listitem>
     <para>
      This chapter shows how to configure ${projectName}
      as a SAML 2.0 Identity Provider.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><link
     xlink:show="new"
     xlink:href="gateway-guide#chap-oauth2-rs"
     xlink:role="http://docbook.org/xlink/role/olink"
     ><citetitle>${projectName} as an OAuth 2.0 Resource Server</citetitle></link>
    </term>
    <listitem>
     <para>
      This chapter explains how ${projectName} acts
      as an OAuth 2.0 Resource Server,
      and follows with a tutorial
      that shows you how to use ${projectName} as a resource server.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><link
     xlink:show="new"
     xlink:href="gateway-guide#chap-oauth2-client"
     xlink:role="http://docbook.org/xlink/role/olink"
     ><citetitle>${projectName} as an OAuth 2.0 Client</citetitle></link>
    </term>
    <listitem>
     <para>
      This chapter explains how ${projectName} acts
      as an OAuth 2.0 client or OpenID Connect 1.0 relying party,
      and follows with a tutorial
      that shows you how to use ${projectName}
      as an OpenID Connect 1.0 relying party.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><link
     xlink:show="new"
     xlink:href="gateway-guide#chap-routing"
     xlink:role="http://docbook.org/xlink/role/olink"
     ><citetitle>Configuring Routes</citetitle></link>
    </term>
    <listitem>
     <para>
      This chapter shows how to configure ${projectName}
      to allow dynamic configuration changes and route to multiple applications.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><link
     xlink:show="new"
     xlink:href="gateway-guide#chap-gateway-templates"
     xlink:role="http://docbook.org/xlink/role/olink"
     ><citetitle>Configuration Templates</citetitle></link>
    </term>
    <listitem>
     <para>
      This chapter provides sample ${projectName} configuration files
      for common use cases.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   ForgeRock can also help you succeed in your projects involving ${projectName}.
   You can purchase ${projectName} support subscriptions and training courses
   from ForgeRock and from consulting partners around the world and in your area.
   To contact ForgeRock, send mail to
   <link xlink:href="mailto:info@forgerock.com">info@forgerock.com</link>.
   To find a partner in your area, see
   <link
    xlink:show="new"
    xlink:href="http://forgerock.com/partners/find-a-partner/" />.
  </para>
 </section>
</chapter>
