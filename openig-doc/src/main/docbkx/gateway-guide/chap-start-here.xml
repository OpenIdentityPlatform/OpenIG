<?xml version="1.0" encoding="UTF-8"?>
<!--
  ! CCPL HEADER START
  !
  ! This work is licensed under the Creative Commons
  ! Attribution-NonCommercial-NoDerivs 3.0 Unported License.
  ! To view a copy of this license, visit
  ! http://creativecommons.org/licenses/by-nc-nd/3.0/
  ! or send a letter to Creative Commons, 444 Castro Street,
  ! Suite 900, Mountain View, California, 94041, USA.
  !
  ! You can also obtain a copy of the license at
  ! src/main/resources/legal-notices/CC-BY-NC-ND.txt.
  ! See the License for the specific language governing permissions
  ! and limitations under the License.
  !
  ! If applicable, add the following below this CCPL HEADER, with the fields
  ! enclosed by brackets "[]" replaced with your own identifying information:
  !      Portions Copyright [yyyy] [name of copyright owner]
  !
  ! CCPL HEADER END
  !
  !      Copyright 2014-2015 ForgeRock AS.
  !
-->
<chapter xml:id="chap-start-here"
         xmlns="http://docbook.org/ns/docbook" version="5.0" xml:lang="en"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://docbook.org/ns/docbook
                             http://docbook.org/xml/5.0/xsd/docbook.xsd"
         xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Understanding ${projectName}</title>

 <para>
  This chapter introduces ${projectName}.
  In this chapter, you will learn the essentials of using ${projectName} including:
 </para>

 <itemizedlist>
  <listitem>
   <para>
    What problems ${projectName} solves and where it fits in your deployment
   </para>
  </listitem>

  <listitem>
   <para>
    How ${projectName} acts on HTTP requests and responses
   </para>
  </listitem>

  <listitem>
   <para>
    How the configuration files for ${projectName} are organized
   </para>
  </listitem>

  <listitem>
   <para>
    The roles played by routes, filters, handlers, and chains,
    which are the building blocks of an ${projectName} configuration
   </para>
  </listitem>
 </itemizedlist>

 <section xml:id="about">
  <title>About ${projectName}</title>

  <para>
   Most organizations have valuable existing services
   that are not easily integrated into newer architectures.
   These existing services cannot often be changed.
   Many client applications cannot communicate
   as they lack a gateway to bridge the gap.
   <xref linkend="figure-missing-gateway" />
   illustrates one example of a missing gateway.
  </para>

  <figure xml:id="figure-missing-gateway">
   <title>Missing Gateway</title>

   <mediaobject>
    <alt>Missing Gateway</alt>
    <imageobject>
     <imagedata fileref="images/missing-gateway.png" format="PNG" />
    </imageobject>
    <textobject>
     <para>
      Sometimes new client requests are not appropriate for existing services,
      or service responses are not appropriate for new clients.
     </para>
    </textobject>
   </mediaobject>
  </figure>

  <para>
   ${projectName} works as an HTTP gateway, also known as a reverse proxy.
   ${projectName} is deployed on a network so it can intercept
   both client requests and server responses.
   <xref linkend="figure-gateway-deployed" />
   illustrates a ${projectName} deployment.
  </para>

  <figure xml:id="figure-gateway-deployed">
   <title>${projectName} Deployed</title>

   <mediaobject>
    <alt>${projectName} Deployed</alt>
    <imageobject>
     <imagedata fileref="images/gateway-deployed.png" format="PNG" />
    </imageobject>
    <textobject>
     <para>
      ${projectName} helps integrate existing services into newer architectures.
     </para>
    </textobject>
   </mediaobject>
  </figure>

  <para>
   Clients exchange with protected servers through ${projectName}.
   ${projectName} can be configured to add new capabilities to existing services
   without affecting current clients or servers.
  </para>

  <itemizedlist>
   <para>
    The list that follows names some of what you can add by using ${projectName}:
   </para>

   <listitem>
    <para>
     Access management integration
    </para>
   </listitem>

   <listitem>
    <para>
     Application &amp; API security
    </para>
   </listitem>

   <listitem>
    <para>
     Credential replay
    </para>
   </listitem>

   <listitem>
    <para>
     OAuth 2.0 support
    </para>
   </listitem>

   <listitem>
    <para>
     OpenID Connect 1.0 support
    </para>
   </listitem>

   <listitem>
    <para>
     Network traffic control
    </para>
   </listitem>

   <listitem>
    <para>
     Proxy with request &amp; response capture
    </para>
   </listitem>

   <listitem>
    <para>
     Request &amp; response rewriting
    </para>
   </listitem>

   <listitem>
    <para>
     SAML 2.0 federation support
    </para>
   </listitem>

   <listitem>
    <para>
     Single sign-on
    </para>
   </listitem>
  </itemizedlist>

  <para>
   ${projectName} supports these capabilities
   as out-of-the-box configuration options.
   Once you understand the essential concepts covered in this chapter,
   try the additional instructions in this guide
   to use ${projectName} to add other features.
  </para>
 </section>

 <section xml:id="the-exchange">
  <title>The Exchange</title>

  <para>
   ${projectName} handles HTTP requests and responses
   with a wrapper called the <firstterm>exchange</firstterm>.
  </para>

  <para>
   The exchange encapsulates HTTP requests and responses
   that pass through ${projectName},
   as well as the principal associated with the request,
   the session context associated with the client,
   and any other state information needed.
   It is easy to access arbitrary state information with ${projectName}
   through the exchange for use throughout the duration of the exchange,
   including when the exchange calls for interaction with additional services.
  </para>

  <para>
   ${projectName} includes information in the exchange
   about the client that made the incoming request,
   including the client host, port, and IP address,
   and also the user-agent description,
   the login of the user making the request,
   and the X.509 certificates presented by the client
   when these are available as part of the request.
  </para>
 </section>

 <section xml:id="the-configuration">
  <title>The Configuration</title>

  <para>
   The configuration for ${projectName} is stored in flat files,
   which are mainly in JavaScript Object Notation (JSON) format.<footnote>
    <para>
     ${projectName} also uses Java properties files and XML files for SAML 2.0.
    </para>
   </footnote>
   Configure ${projectName} by editing the JSON files.
  </para>

  <para>
   When installation is complete, add at least one configuration file.
   Each configuration file holds a JSON object,
   which specifies a <firstterm>handler</firstterm> to deal with the exchange.
   A handler is an object responsible for producing a response to a request.
   Every route must call a handler.
  </para>

  <para>
   The following very simple configuration routes exchanges
   to be handled according to separate route configurations:
  </para>

  <programlisting language="javascript">
{
    "handler": {
        "type": "Router"
    }
}
  </programlisting>

  <para>
   Notice in this case that the handler field takes an object as its value.
   This is an inline declaration.
   If you only use the object once where it is declared,
   then it makes sense to use an inline declaration.
  </para>

  <para>
   To change the definition of an object defined by default
   or when you need to declare an object once and use it multiple times,
   declare the object in the <firstterm>heap</firstterm>.
   The heap is a collection of named configuration objects
   that can be referenced by their names from elsewhere in the configuration.
  </para>

  <para>
   The following example declares a reusable Router
   and references it by its name, as follows:
  </para>

  <programlisting language="javascript">
{
    "handler": "My Router",
    "heap": [
        {
            "name": "My Router",
            "type": "Router"
        }
    ]
}
  </programlisting>

  <para>
   Notice that the heap takes an array.
   Because the heap holds configuration objects all at the same level,
   you can impose any hierarchy or order that you like when referencing objects.
   Note that when you declare all objects in the heap and reference them by name,
   neither hierarchy nor ordering are obvious
   from the structure of the configuration file alone.
  </para>

  <itemizedlist>
   <para>
    Each configuration object has a <firstterm>type</firstterm>,
    a <firstterm>name</firstterm>, and an optional <firstterm>config</firstterm>.
    For example:
   </para>

   <listitem>
    <para>
     The type must be the type name of the configuration object.
     ${projectName} defines many types for different purposes.
    </para>
   </listitem>

   <listitem>
    <para>
     The name takes a string that is unique in the list of objects.
    </para>

    <para>
     You can omit this field when declaring objects inline.
    </para>
   </listitem>

   <listitem>
    <para>
     The contents of the config object depend on the type.
    </para>

    <para>
     When all the configuration settings for the type are optional,
     the config field is also optional, as in the Router example.
     If all configuration settings are optional,
     then omitting the config field,
     setting the config field to an empty object,
     <literal>"config": {}</literal>,
     or setting <literal>"config": null</literal>
     all signify that the object uses default settings.
    </para>
   </listitem>
  </itemizedlist>

  <para>
   The configuration can specify additional objects as well.
   For example, you can configure an <firstterm>HttpClient</firstterm> object
   that ${projectName} uses to connect to servers.
   The following HttpClient configuration uses defaults for all settings,
   except <firstterm>hostnameVerifier</firstterm>,
   which it configures to verify host names in SSL certificates
   in the same way as most browsers:
  </para>

  <programlisting language="javascript">
{
    "name": "HttpClient",
    "type": "HttpClient",
    "config": {
        "hostnameVerifier": "BROWSER_COMPATIBLE"
    }
}
  </programlisting>

  <para>
   <firstterm>Decorators</firstterm> are additional heap objects
   that let you extend what another object can do.
   For example, a <firstterm>CaptureDecorator</firstterm>
   extends the capability of filters and handlers to log requests and responses.
   A <firstterm>TimerDecorator</firstterm> logs processing times.
   Decorate configuration objects with decorator names as field names.
   By default ${projectName} defines both
   a CaptureDecorator named <literal>capture</literal>
   and also a TimerDecorator named <literal>timer</literal>.
   Log requests, responses, and processing times
   by adding decorations as shown in the following example:
  </para>

  <programlisting language="javascript">
{
    "handler": {
        "type": "Router",
        "capture": [ "request", "response" ],
        "timer": true
    }
}
  </programlisting>

  <para>
   ${projectName} also creates additional utility objects with default settings,
   including HttpClient, <firstterm>LogSink</firstterm>,
   and <firstterm>TemporaryStorage</firstterm>.
   These objects can be referenced by name
   and do not need to be configured
   unless they are needed to override the default configurations.
  </para>

  <para>
   <firstterm>Routes</firstterm> are configuration objects
   whose behavior is triggered when their conditions are matched.
   Routes inherit settings from their parent configurations.
   This means that you can
   configure global objects in the "heap" of the base configuration for example,
   and then reference the objects by name
   in any other ${projectName} configuration.
  </para>
 </section>

 <section xml:id="routing">
  <title>Routing</title>

  <para>
   ${projectName} routing lets you use multiple configuration files.
   Routing also lets ${projectName} reload configurations
   that you change at runtime without restarting ${projectName}.
  </para>

  <para>
   Use routing where ${projectName} protects multiple services
   or multiple and different endpoints of the same service.
   Routing is also used when working with an exchange with multiple steps,
   because the client must be redirected to authenticate
   with an identity provider before accessing the service.
  </para>

  <para>
   As illustrated in <xref linkend="the-configuration" />
   a <firstterm>router</firstterm> manages the routes in its file system directory,
   periodically reloading changed routes
   unless it is configured to load them only at startup.
  </para>

  <para>
   A router does not explicitly specify any routes.
   Instead the router specifies a directory where route configuration files are found,
   or uses the default directory.
   Routes specify their own <firstterm>condition</firstterm>,
   which is an expression that evaluates to true, false, or null.
   If a route condition is true, then the route handles the exchange.
  </para>

  <para>
   The following example specifies a condition
   that is true when the request path is <literal>/login</literal>:
  </para>

  <programlisting language="javascript">
"condition": "${matches(exchange.request.uri.path, '^/login')}"
  </programlisting>

  <para>
   If the route has no condition, or if the value of the condition is null,
   then the route matches any exchange.
   Furthermore, ${projectName} orders routes lexicographically by file name.
  </para>

  <para>
   You can use these features to have both optional and default routes.
   For example, you could name your routes to check conditions in order:
   <filename>01-login.json</filename>,
   <filename>02-protected.json</filename>,
   <filename>99-default.json</filename>.
   Alternatively, you can name routes by using the name property on the route.
  </para>

  <para>
   A router configuration can specify where to look for route files.
   As a router is a kind of handler, routes can have routers, too.
  </para>
 </section>

 <section xml:id="filters-handlers-chains">
  <title>Filters, Handlers, and Chains</title>

  <para>
   Routing only delegates exchange handling.
   It does not actually modify the exchanges.
   To modify an exchange, chain together filters and handlers.
  </para>

  <itemizedlist>
   <listitem>
    <para>
     A <firstterm>handler</firstterm> either delegates to another handler,
     or it produces a response.
    </para>

    <para>
     One way to produce a response is
     to send a request to and receive a response from an external service.
     In this case, ${projectName} acts as a client of the service,
     often on behalf of the client whose request initiated the exchange.
    </para>

    <para>
     Another way to produce a response is
     to build a response either statically or based on something in the exchange.
     In this case, ${projectName} plays the role of server,
     generating a response to return to the client.
    </para>
   </listitem>

   <listitem>
    <para>
     A <firstterm>filter</firstterm> either transforms data in the exchange,
     or performs an action when the exchange passes through the filter.
    </para>

    <para>
     A filter can leave the exchange unchanged.
     For example, it can log the exchange as it passes through the filter.
     Alternatively, it can change request or response.
     For example, it can generate a static request to replace the client request,
     add a header to the request, or remove a header from a response.
    </para>
   </listitem>

   <listitem>
    <para>
     A <firstterm>chain</firstterm> is a type of handler
     that dispatches processing to a list of filters in order,
     and then to the handler.
    </para>

    <para>
     A chain can be placed anywhere in a configuration that a handler can be placed.
     Filters process the incoming exchange
     and pass it on to the next filter and the handler.
     After the handler produces a response,
     the filters process the outgoing exchange as it makes its way to the client.
     Note that the same filter can process
     both the incoming request and the outgoing response
     but most filters do one or the other.
    </para>
   </listitem>
  </itemizedlist>

  <para>
   <xref linkend="figure-chain" /> shows the flow inside a chain with
   a request filter transforming the request,
   a response filter transforming the response,
   and a handler sending a request to a service to get a response.
   Notice how the flow traverses the filters in reverse order
   when the outgoing exchange comes back from the handler.
  </para>

  <figure xml:id="figure-chain">
   <title>Flow Inside a Chain</title>

   <mediaobject>
    <alt>Flow Inside a Chain</alt>
    <imageobject>
     <imagedata fileref="images/chain.png" format="PNG" />
    </imageobject>
    <textobject>
     <para>
      In a chain the incoming exchange is processed by the request filters,
      then the handler produces a response.
      The outgoing chain is then processed by response filters.
     </para>
    </textobject>
   </mediaobject>
  </figure>

  <para>
   The route configuration in <xref linkend="example-chain" />
   demonstrates the flow through a chain that does not call an external service.
  </para>

  <example xml:id="example-chain">
   <title>Chain Without An External Service</title>

   <programlisting language="javascript"><![CDATA[
{
    "handler": {
        "type": "Chain",
        "comment": "Base configuration defines the capture decorator",
        "config": {
            "filters": [
                {
                    "type": "HeaderFilter",
                    "comment": "Same header on all requests",
                    "config": {
                        "messageType": "REQUEST",
                        "add": {
                            "X-MyHeaderFilter": [
                                "Added by HeaderFilter to request"
                            ]
                        }
                    }
                },
                {
                    "type": "HeaderFilter",
                    "comment": "Remove X-Powered-By from response",
                    "capture": "response",
                    "config": {
                        "messageType": "RESPONSE",
                        "remove": [
                            "X-Powered-By"
                        ]
                    }
                }
            ],
            "handler": {
                "type": "StaticResponseHandler",
                "comment": "Same response to all requests",
                "capture": "request",
                "config": {
                    "status": 200,
                    "reason": "OK",
                    "headers": {
                        "X-Powered-By": [
                            "${projectName}"
                        ]
                    },
                    "entity": "<html><p>Hello, World!</p></html>"
                }
            }
        }
    }
}
  ]]></programlisting>

   <itemizedlist>
    <para>
     The chain receives the exchange and process it as follows:
    </para>

    <listitem>
     <para>
      The first HeaderFilter adds a header to the incoming request.
     </para>
    </listitem>

    <listitem>
     <para>
      The second HeaderFilter is configured to manage responses, not requests,
      so it simply passes the exchange to the handler.
     </para>
    </listitem>

    <listitem>
     <para>
      The StaticResponseHandler captures (logs) the request.
     </para>
    </listitem>

    <listitem>
     <para>
      The StaticResponseHandler produces a response with an entity body and a header.
     </para>
    </listitem>

    <listitem>
     <para>
      The second HeaderFilter captures (logs) the response.
     </para>
    </listitem>

    <listitem>
     <para>
      The second HeaderFilter removes the header added to the response.
     </para>
    </listitem>

    <listitem>
     <para>
      The first HeaderFilter is configured to manage requests, not responses,
      so it simply passes the outgoing exchange back to ${projectName}.
     </para>
    </listitem>
   </itemizedlist>
  </example>

  <para>
   <xref linkend="example-chain" /> explained how a chain
   processes an exchange when it receives a request.
   <xref linkend="example-chain-exchange" /> illustrates
   the HTTP requests and responses captured
   as the exchange flows through the chain.
  </para>

  <example xml:id="example-chain-exchange">
   <title>Requests and Responses in a Chain</title>

   <programlisting language="http"><![CDATA[
### Original request from user-agent
GET / HTTP/1.1
Host: www.example.com:8080
Accept: */*

### Captured incoming request (inside ${projectName} exchange)
GET / HTTP/1.1
X-MyHeaderFilter: Added by HeaderFilter to request
Accept: */*
Host: www.example.com:8080

### Captured outgoing response (inside ${projectName} exchange)
HTTP/1.1 200 OK
Content-Length: 33
X-Powered-By: ${projectName}

<html><p>Hello, World!</p></html>

### Final response to user-agent
HTTP/1.1 200 OK
Content-Length: 33

<html><p>Hello, World!</p></html>
  ]]></programlisting>
  </example>
 </section>

 <section xml:id="config-comments">
  <title>Using Comments in ${projectName} Configuration Files</title>

  <para>
   The JSON format does not specify a notation for comments.
   If ${projectName} does not recognize a JSON field name,
   it ignores the field.
   As a result, it is possible to use comments in configuration files.
  </para>

  <itemizedlist>
   <para>
    Use the following conventions when commenting
    to ensure your configuration files are easier to read:
   </para>

   <listitem>
    <para>
     Use <literal>comment</literal> fields to add text comments.
     <xref linkend="figure-comment-field" /> illustrates
     a CaptureDecorator configuration that includes a text comment:
    </para>

    <figure xml:id="figure-comment-field">
     <title>Using a Comment Field</title>

    <programlisting language="javascript">
{
    "name": "capture",
    "type": "CaptureDecorator",
    "comment": "Write request and response information to the LogSink",
    "config": {
        "captureEntity": true
    }
}
     </programlisting>
    </figure>
   </listitem>

   <listitem>
    <para>
     Use an underscore (<literal>_</literal>) to comment a field temporarily.
     <xref linkend="figure-comment-underscore" /> illustrates a CaptureDecorator
     that has <literal>"captureEntity": true</literal> commented out.
     As a result, it uses the default setting
     (<literal>"captureEntity": false</literal>).
    </para>

    <figure xml:id="figure-comment-underscore">
     <title>Using an Underscore</title>

    <programlisting language="javascript">
{
    "name": "capture",
    "type": "CaptureDecorator",
    "config": {
        "_captureEntity": true
    }
}
     </programlisting>
    </figure>
   </listitem>
  </itemizedlist>
 </section>

 <section xml:id="next-steps">
  <title>Next Steps</title>

  <para>
   Now that you understand the essential concepts,
   start using ${projectName} with the help of the following chapters.
  </para>

  <variablelist>
   <varlistentry>
    <term><link
     xlink:show="new"
     xlink:href="gateway-guide#chap-quickstart"
     xlink:role="http://docbook.org/xlink/role/olink"
     ><citetitle>Getting Started</citetitle></link>
    </term>
    <listitem>
     <para>
      This chapter shows you how to get ${projectName} up and running quickly.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><link
     xlink:show="new"
     xlink:href="gateway-guide#chap-install"
     xlink:role="http://docbook.org/xlink/role/olink"
     ><citetitle>Installation in Detail</citetitle></link>
    </term>
    <listitem>
     <para>
      This chapter covers more advanced installation procedures.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><link
     xlink:show="new"
     xlink:href="gateway-guide#chap-credentials-tutorial"
     xlink:role="http://docbook.org/xlink/role/olink"
     ><citetitle>Getting Login Credentials From Data Sources</citetitle></link>
    </term>
    <listitem>
     <para>
      This chapter shows you how to configure ${projectName}
      to look up credentials in external sources, such as a file or a database.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><link
     xlink:show="new"
     xlink:href="gateway-guide#chap-password-capture-replay-tutorial"
     xlink:role="http://docbook.org/xlink/role/olink"
     ><citetitle>Getting Login Credentials From OpenAM</citetitle></link>
    </term>
    <listitem>
     <para>
      This chapter walks you through an OpenAM integration
      with OpenAM's password capture and replay feature.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><link
     xlink:show="new"
     xlink:href="gateway-guide#chap-federation"
     xlink:role="http://docbook.org/xlink/role/olink"
     ><citetitle>${projectName} as a SAML 2.0 Service Provider</citetitle></link>
    </term>
    <listitem>
     <para>
      This chapter shows how to configure ${projectName}
      as a SAML 2.0 Identity Provider.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><link
     xlink:show="new"
     xlink:href="gateway-guide#chap-oauth2-rs"
     xlink:role="http://docbook.org/xlink/role/olink"
     ><citetitle>${projectName} as an OAuth 2.0 Resource Server</citetitle></link>
    </term>
    <listitem>
     <para>
      This chapter explains how ${projectName} acts
      as an OAuth 2.0 Resource Server,
      and follows with a tutorial
      that shows you how to use ${projectName} as a resource server.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><link
     xlink:show="new"
     xlink:href="gateway-guide#chap-oauth2-client"
     xlink:role="http://docbook.org/xlink/role/olink"
     ><citetitle>${projectName} as an OAuth 2.0 Client</citetitle></link>
    </term>
    <listitem>
     <para>
      This chapter explains how ${projectName} acts
      as an OAuth 2.0 client or OpenID Connect 1.0 relying party,
      and follows with a tutorial
      that shows you how to use ${projectName}
      as an OpenID Connect 1.0 relying party.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><link
     xlink:show="new"
     xlink:href="gateway-guide#chap-routing"
     xlink:role="http://docbook.org/xlink/role/olink"
     ><citetitle>Configuring Routes</citetitle></link>
    </term>
    <listitem>
     <para>
      This chapter shows how to configure ${projectName}
      to allow dynamic configuration changes and route to multiple applications.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><link
     xlink:show="new"
     xlink:href="gateway-guide#chap-gateway-templates"
     xlink:role="http://docbook.org/xlink/role/olink"
     ><citetitle>Configuration Templates</citetitle></link>
    </term>
    <listitem>
     <para>
      This chapter provides sample ${projectName} configuration files
      for common use cases.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </section>
</chapter>
